checkpoint three temproary addresses for important variables:
seconds passed:  0x100000b0 (set to ZERO upon init)
minutes passed:  0x100000b4 (set to ZERO upon init)
state:           0x100000c0
SW_RTC:          0x100000c4 (set to ZERO upon init)
timer_print_bit: 0x100000c8 (set to ONE upon init)
inIdx:           0x100000d0 (set to ZERO upon init)
outIdx:          0x100000d4 (set to ZERO upon init)
buffer:          0x100000d8


start program: 0x10000d00

spec broken down:
isr resides in start.s (isr folder) 

timer isr: 
add 1 second to compare register (50M cycles)
add 1 second to seconds passed global value
if == 60, set to 0, increment minutes passed
if timer_print_bit is set:
	call C print function (may be assembly if we decide) (no arguments), print in form mm:ss

rtc_isr:
increment every time count overflows

UARTRX_isr: (done in assembly in start.s)
receive from UART, store to STATE
case (state)
	e: set timer_print_bit (global var)
	d: clear timer_print_bit
	else stores into STATE (used by application code)

UARTTX_isr: 
>? if FIFO empty (inIdx == outIdx) send null (or carat for debugging)
otherwise dequeue from fifo
jal to write_UART


